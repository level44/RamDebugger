\gdef\putwordsee{see}
\input gid_base.tex
\input psfig.sty
\pssilent %\psnoisy
\hoffset=1.52cm
\input texinfo @c -*-texinfo-*-

@tex

\def\verysmallbook{
  \global\chapheadingskip = 15pt plus 4pt minus 2pt
  \global\secheadingskip = 12pt plus 3pt minus 2pt
  \global\subsecheadingskip = 9pt plus 2pt minus 2pt
  %
  \global\lispnarrowing = 0.3in
  \setleading{12pt}
  \advance\topskip by -1cm
  \global\parskip 2pt plus 1pt
  \global\hsize = 5.5in
  \global\vsize=6in
  \global\tolerance=700
  \global\hfuzz=1pt
  \global\contentsrightmargin=0pt
  \global\deftypemargin=0pt
  \global\defbodyindent=.5cm
  %
  \global\pagewidth=\hsize
  \global\pageheight=\vsize
  %
  \global\let\smalllisp=\smalllispx
  \global\let\smallexample=\smalllispx
  \global\def\Esmallexample{\Esmalllisp}
  \global\hoffset=1.75cm
}

\verysmallbook

@end tex


@c To update all in emacs use: C-u C-c C-u m
@c to get a gid.info file without running makeinfo try: C-c C-e C-b


@c %**start of header
@setfilename ramdebugger.info
@settitle RamDebugger: A graphical and interactive debugger for Tcl-TK
@paragraphindent 3
@iftex
@c @smallbook
@c @afourpaper
@c @finalout   ---to avoid black squares in hboxes (long lines)---
@finalout
@end iftex
@c %**end of header ptype.texinfo

@setchapternewpage odd

@set photo

@set Version 4.4
@set Date August 2004
@set Copyright 2002-2004 Ramon Ribó

@set CVSVersion  $Revision: 1.28 $
@ifinfo
Copyright @value{Copyright}
@end ifinfo

@titlepage
@title RamDebugger @value{Version}:
@subtitle graphical and interactive debugger for Tcl-TK
@author Copyright @value{Copyright}
@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll

Copyright @copyright{} @value{Copyright}

@url{http://gid.cimne.upc.es/ramsan}

@end titlepage

@iftex
@headings off
@end iftex

@node Top, Introduction and Setup, (dir), (dir)
@comment node-name, next, previous, up


RamDebugger: A graphical and interactive debugger for Tcl-TK

@menu
* Introduction and Setup::      
* Using RamDebugger::           
* How does it work?::           
* Known bugs::                  
* Additional packages included in the distribution::  
* License::                     

@detailmenu
 --- The Detailed Node Listing ---

Introduction and Setup

* Introduction::                
* Changes::                     
* web page::                    
* Download::                    
* Installation and prerequisites::  
* Starting RamDebugger::        

Using RamDebugger

* Debugging locally::           
* Debugging remotely::          
* Using Ramdebugger as package::  
* Debugging GiD::               
* Debugging RamDebugger::       
* Compiling/Debugging c++::     
* Timing control::              
* Windows hierarchy::           
* Expressions window::          
* Revisions::                   
* Auto save::                   

@end detailmenu
@end menu

@ifinfo
CN @value{Version} @value{Date}
@end ifinfo

@node Introduction and Setup, Using RamDebugger, Top, Top
@chapter Introduction and Setup

@menu
* Introduction::                
* Changes::                     
* web page::                    
* Download::                    
* Installation and prerequisites::  
* Starting RamDebugger::        
@end menu

@node Introduction, Changes, Introduction and Setup, Introduction and Setup
@section Introduction

RamDebugger is a graphical debugger for the scripting lenguage Tcl-TK. It can operate
basically in two modes:
@itemize @bullet
@item @b{GUI mode:} The normal one, is the one that appears when opening normally
the program and has a Graphical User Interface.
@item @b{Text mode:} In this mode, the GUI is not displayed and the debugger is
executed as a set of text commands, similar to GDB. To use RamDebugger in this mode,
load it inside Tkcon.
@end itemize 
With RamDebugger, it is possible to make @b{Local Debugging}, where the debugger starts
the program to be debugged. and @b{Remote debugging}, where the program to debug is already
started and RamDebugger connects to it.

RamDebugger has additional capabilities like:
@itemize @bullet
@item Editing the code. It is possible to edit the code inside its own editor and resend
the new code without closing the debugged program.
@item The TCL-TK source code is colorized and supports automatic indentation.
@item When stopping the debugger is one source code line, it is possible to view all the
variables and expression values, as well as change them.
@item It has additional options to measure execution times in the debugged program.
@item Works in Linux and Windows
@item Includes additional packages, like Tkcon and VisualRegexp, developed by third party
people, as a convenience for RamDebugger users.
@item The same program is an IDE for compiling and debugging @b{c} and @b{c++}
@end itemize 


@ifhtml
<center>
<table><tr>
<td><img src="images/main_gui.gif"><td><img src="images/tkcon_gui.gif">
<tr><td>GUI mode<td>Non GUI mode inside Tkcon
</table>
</center><p>
@end ifhtml

@b{Note:} RamDebugger can also be an IDE for compiling and debugging c/c++ code. It
uses GDB as a backend. See @ref{Compiling/Debugging c++} for details.

@node Changes, web page, Introduction, Introduction and Setup
@section Changes

@item Fast c++ instrumenter
@item Profile procedures
@item Files list obtained with Ctrl-Tab has a new alternative list based on
current directory

Changes From version 3.2 to version 4.4

@itemize @bullet
@item Implemented secondary view in the Editor
@item Implemented auto save, based on file revisions
@item New inline file chooser to fast change buffers
@item The search controls are now integrated inside the main GUI
@item RamDebugger can automatically manage revisions of files (based internally on CVS)
@item Added program @code{tkdiff} for visualizing file differences
@item New option in Help to associate RamDebugger as command in the .tcl extension in Windows
@item When TCL raises and error, RamDebugger shows last visited line
@item If files contain, in first lines something like @code{# -*- coding: utf-8;-*-} they are
considered as in utf-8 encoding
@item RamDebugger works only for TCL version 8.4
@item Open file and save file browser follow the preferences extensions for file types
@item Added new macro for going to function names
@item Corrections for when several pop-up windows appear at the same time
@end itemize

Changes From version 3.1 to version 3.2

@itemize @bullet
@item Added @b{Snit} support
@item Added contextual menu in marker zone (left margin of text)
@item Added Enable/disable to breakpoints
@item Added command stop in the Debug menu
@item Added command to break execution in any moment
@item Added zoom option to @b{Display Windows hierarchy}
@item The cache directory (used internally by RamDebugger) is now created in the user directories instead of inside the installation directory
@item Option @b{Pick window} in Windows hierarchy
@item It is necessary to stop debugging before start debugging again
@end itemize

Changes From version 3.0 to version 3.1

@itemize @bullet
@item GiD customization files
@item User can choose file extensions for every file type
@item New macro for applying regsub to a region
@item New option in @b{Current file arguments}: file type can be @b{TCL} or @b{TK}
@item New option in @b{Current file arguments}: Another file can be started to begin local debugging
@item RamDebugger::OpenFileSaveHandler
@end itemize

Changes From version 2.8 to version 3.0

@itemize @bullet
@item Count lines of code of a project (LOC)
@item It is possible to create and use macros defined in TCL
@item Values in User defined var & Local vars display content in balloon
@item Autodisplay variables now displays also array variables
@item Better interactive indentation and colors
@item Menu close
@item Drawing dynamically closing braces when editing
@item better stack position
@item search & replace
@item comment lines are indented in normal column
@item Added reinstrument to menu Debug
@item If tkcon is open, output goes also to tkcon
@item New menu options in Tkcon to send commands to debugged program
@end itemize

Changes From version 2.6 to version 2.8

@itemize @bullet
@item Option to instrument last line in proc (to avoid error when not using return)
@item corrected error when brackets are not paired in comments
@item Script of command @b{bind} is now instrumented
@end itemize

Changes From version 2 to version 2.6

@itemize @bullet
@item RamDebugger can now be used as a package
@item When editing one file, breakpoints are modified in position accordingly
@item Command @b{console} works correctly now in local mode
@item It is possible to save possitions in the editor to return later
@item Activated drag and drop (works for Windows and for platforms that have
package tkdnd compiled).
@end itemize

Changes From version 1 to version 2

@itemize @bullet
@item Tested for Tcl/Tk @b{8.4}
@item When @b{Tkhtml} is not compiled for the given platform, gives message and continues
@item Added contextual help for programming commands. If there are manual pages (UNIX), it
also uses them if @b{man2html} is found in the system.
@item When debugging local, possibility to choose debug TCL or TK
@item Improved the build process and the debugging for C/C++
@item Improved several windows, like the @b{Breakpoints window} and @b{Goto line}
@item Added option to search in files
@item Several speed problems in linux were related to the TCL bug with @b{raise}
      command. Implemented one workaround.
@item Fixed many bugs related to parsing files and other.
@end itemize 

@node web page, Download, Changes, Introduction and Setup
@section web page

RamDebugger web page is at: @url{http://gid.cimne.com/RamDebugger}

@node  Download, Installation and prerequisites, web page, Introduction and Setup
@section Download

RamDebugger can be download from
@url{http://gid.cimne.com/RamDebugger/RamDebugger@value{Version}.zip}
@url{http://gid.cimne.com/RamDebugger/RamDebugger@value{Version}.kit}

@node Installation and prerequisites, Starting RamDebugger, Download, Introduction and Setup
@section Installation and prerequisites

The only prerequisite before executing RamDebugger is to have Tcl-Tk installed. The tested
version is Tcl-Tk8.4
They can be obtained from @url{http://tcl.activestate.com}.
@sp 1
RamDebugger has been tested on Windows and on Linux. For other UNIXes and MAC, it is necessary
to obtain, separately, the package Tkhtml compiled for the platform. Without it, the help
cannot be visualized.
@sp 1
All the additional packages that RamDebugger uses, are already contained in the distribution.
@sp 1
The distribution comes in a ZIP file. Once it is unpacked in one directory, RamDebugger is
ready to begin to work.
@sp 1
@strong{Note:} Text files inside ZIP files have Windows line-ends. UNIX and Linux users
may want to unzip using something like @code{unzip -a ...} in order to change the line-ends
to Unix ones. After doing this and after changing the program to executable with @code{chmod +x
RamDebugger.tcl}, it is possible to start the program by just writing @code{RamDebugger.tcl}

@node Starting RamDebugger,  , Installation and prerequisites, Introduction and Setup
@section Starting RamDebugger

To start RamDebugger on Windows, double-click over @b{RamDebugger.tcl}.

To start Ramdebugger on UNIX, in the command line use something similar to:
@b{wish RamDebugger.tcl}

or just: @b{RamDebugger.tcl} if you followed the instructions in 
@xref{Installation and prerequisites}.

To start RamDebugger in text mode inside Tkcon, one of the following possibilities can
be done:
@itemize @bullet
@item Open Tkcon and do:
@example
source RamDebugger.tcl
namespace import RamDebugger::*
rhelp
@end example
@item Modify the Tkcon initialization file (@t{tkcon.cfg} or @t{.tkconrc}) and add:
@verbatim
   set ::tkcon::OPT(slaveeval) {
       source "<Path to RamDebugger>/RamDebugger.tcl"
       namespace import RamDebugger::*
       puts "Welcome to Ramdebugger inside tkcon. Use 'rhelp' for help"
   }
@end verbatim
@end itemize 

@node  Using RamDebugger, How does it work?, Introduction and Setup, Top
@chapter Using RamDebugger

@menu
* Debugging locally::           
* Debugging remotely::          
* Using Ramdebugger as package::  
* Debugging GiD::               
* Debugging RamDebugger::       
* Compiling/Debugging c++::     
* Timing control::              
* Windows hierarchy::           
* Expressions window::          
* Revisions::                   
* Auto save::                   
@end menu

@node Debugging locally, Debugging remotely, Using RamDebugger, Using RamDebugger
@section Debugging locally

To debug a TCL file locally, apply the following steps:

@itemize @bullet
@item Load the TCL file inside RamDebugger with @code{Files->Open file}. To make a test,
use the example located in @b{<RamDebugger directory>/Examples/example1.tcl}
@item Set a breakpoint in line 4 with @code{Debug->Set breakpoint} or press @b{F9} after
having the cursor in the desired line.
@item Start the debugger with @code{Debug->Go} or press @b{F5}. A grey arrow at the left
of the text indicates that the program has stopped in that line.
@item to continue one line, use @code{Debug->Next} or press @b{F10}.
@item Use @code{Edit->Goto line->27} and press @code{Debug->Continue to}
@item Modify source code line @b{21} from:
@example
	set cc $bb--qq
@end example
to:
@example
	set cc $bb--qq2
@end example
@item to continue one line, entering in functions, use @code{Debug->Step} or press @b{F11}.
@item Press @b{F11} several times until arrow is in line @b{22}
@item Put the mouse cursor over variable @b{cc} and leave it there for aprox. one second.
The value of the variable appears in a popup window. Note that it holds the new value,
after the modification of the code.
@item To see the value of one expression, open the window: @code{Debug->Expressions} and
write: @code{[string length $i]+3}
@item To modify the value of variable @b{i}, enter @b{i} in the left column of the @b{User
defined variables}, enter the new value in the right column and pres @code{Return}.
@end itemize 

@node Debugging remotely, Using Ramdebugger as package, Debugging locally, Using RamDebugger
@section Debugging remotely

To debug a TCL file remotely, apply the following steps:

@itemize @bullet
@item execute the external program outside of RamDebugger. In this case, execute 
@b{Examples/example2.tcl} by double clicking over it or using @code{wish example2.tcl}
@item Open RamDebugger
@item Load the TCL file inside RamDebugger with @code{Files->Open file}. In this case,
use the example located in @b{<RamDebugger directory>/Examples/example2.tcl}
@item Set a breakpoint in line 29 with @code{Debug->Set breakpoint} or press @b{F9} after
having the cursor in the desired line.
@item Start debugging remotely with @b{File->Debug on->example2}
@sp 1
@strong{Note:} Depending on the preferences, it may be necessary to do
@code{File->Debug on->Update remotes} before finding the remote program in the menu list.
Depending on the computer (in Windows), it can be necessary to wait for several seconds
for RamDebugger to find the remote program.
@item Press button @b{Go} in the remote application
@item Program should stop in line 29. From now, it is possible to use similar commands
than in local debugging (@pxref{Debugging locally})
@end itemize

To debug remotely, in Windows it is necessary to load the package @t{comm} in the remote
program. To do so use add something similar to the code below in you program, in any
place that gets executed before beginning the debug session (typically at the beginning
of your program):
@example
    lappend ::auto_path <RamDebugger path>/addons
    package require commR
    comm::register application_name 1
@end example
@strong{Note:} The package @t{commR} included in RamDebugger is based on the package @b{comm} 
in tcllib with some modifications. Use always @b{commR} instead of @b{comm}. This package uses
sockets for communication. If you have a firewall in your computer, maybe it will not work.
@sp 1
In Linux/Unix, the communication is made with the command @b{send}, So, it is only necessary
to have this command enabled in the program, which is true by default.
@sp 1
@strong{Note:} It can be necessary to check the security of the server in Unix before being
able to use @b{send}. As a fast workaround, write command @b{xhost -} in the UNIX command
line.

@node Using Ramdebugger as package, Debugging GiD, Debugging remotely, Using RamDebugger
@section Using Ramdebugger as package

Check @code{example4.tcl} to see how @b{Ramdebugger} can be used as a package.

@node  Debugging GiD, Debugging RamDebugger, Using Ramdebugger as package, Using RamDebugger
@section Debugging GiD

GiD is a pre/postprocessing program for Finite Element Analysis that uses TCL/TK as its
extension language @url{http://gid.cimne.upc.es}.

To debug GiD in Windows, it is necessary to load the @b{comm} package. Do it in file:
@code{<GiD installation dir>/scripts/tclfile-opengl} around line 420 before section
@code{Debug funcs}.

In UNIX, it should work directly.

Check section @ref{Debugging remotely} for the rest of the steps to follow.
Check section @ref{Using Ramdebugger as package} for an alternative way of debugging
GiD. Specifically, the package require RamDebugger should be added near the end of
file @code{<GiD installation dir>/scripts/tclfile-opengl}.

@node  Debugging RamDebugger, Compiling/Debugging c++, Debugging GiD, Using RamDebugger
@section Debugging RamDebugger

As a good debugger must do, RamDebugger permmits to debugger itself. As it is not a simple
code, this is a good testing of the program capabilities.
@sp 1
It can be debugged either locally or remotely. To debug itself locally,
open TCL source file @b{RamDebugger.tcl} and choose @code{File->Debug
on->Currentfile}. See @ref{Debugging locally} for details.
@sp 1
To debug itself remotely, open two RamDebuggers. From one of them, connect to the other
with @code{File->Debug on->RamDebugger}. In @b{Windows}, if option @code{Automatically
check remote files} is unset (the default), it can be necessary to use @code{Debug on->
Update remotes} on both RamDebuggers.

@node  Compiling/Debugging c++, Timing control, Debugging RamDebugger, Using RamDebugger
@section Compiling/Debugging c++

RamDebugger can also compile and debug c/c++ projects. It uses as a backend the program
gdb. It is necessary to have @code{gdb} and/or @code{gcc} installed in the computer.
@sp 1
@strong{Note:} It can also be used in Windows, if the @b{mingw} compiler and debugger
have been previously installed. In this case, the directories where the executables are,
must be in the @b{PATH}. Use something similar to:
@example
SET PATH=C:\mingw\bin
@end example
in file @b{AUTOEXEC.BAT} or search for environment variables in Windows200/XP.
@sp 1
Alternatively, it is possible to set in the Preferences window @code{Edit->Preferences},
the directories where the @b{mingw} tools can be found.

@node Timing control, Windows hierarchy, Compiling/Debugging c++, Using RamDebugger
@section Timing control
An additional feature of RamDebugger is the possibility of controlling the computing time
of several parts of the program.

To proceed with the control of time, make the following steps:

@itemize @bullet
@item Load the TCL file inside RamDebugger with @code{Files->Open file}. In this case,
use the example located in @b{<RamDebugger directory>/Examples/example3.tcl}
@item Open window @code{Debug->Timing control}
@item Create a first block with name @b{Block 1}, initial line @b{26} and end line @b{27}.
@item Create another block with name @b{Block 2}, initial line @b{26} and end line @b{26}.
@item Create another block with name @b{Block 3}, initial line @b{27} and end line @b{27}.
@item Press button @b{Start} and select @code{Files->Debug on->Currentfile}.
@item Check the report with button @b{Report}
@end itemize



@ifhtml
<center>
<table><tr>
<td><img src="images/timing_control.gif"><td><img src="images/timing_control_report.gif">
<tr><td>Timing control window<td>Timing control report
</table>
</center><p>
@end ifhtml

@node Windows hierarchy, Expressions window, Timing control, Using RamDebugger
@section Windows hierarchy

With this command, it is possible to draw a graph of the widgets hierarchy in either
the debugged program or in RamDebugger. Moving the cursor over the widgets names, it
is possible to obtain some information on the widget and on its packing/gridding
options.

@node  Expressions window, Revisions, Windows hierarchy, Using RamDebugger
@section Expressions window

To open the window use: @code{Debug->Expressions...}

Examples of possible expressions in TCL:

@itemize @bullet
@item @b{variablename}: Enter the name of a variable 
@item @b{$variablename+4}: Enter a expression like the ones accepted by @b{expr}
@item @b{[lindex $variablename 2]}: Enter any command between brackets
@item @b{[set variablename 6]}: modify variable
@end itemize

Examples of possible expressions in C++:

@itemize @bullet
@item @b{variablename}: Enter the name of a variable 
@item @b{$variablename+4}: Enter any expression that @b{gdb} accepts
@item @b{$variablename[4:2][6::8]}: One extension to the @b{gdb} expressions. Permmits to
print part of a string or vector
@end itemize

@node  Revisions, Auto save, Expressions window, Using RamDebugger
@section Revisions

@code{RamDebugger} uses program @code{cvs} in order to maintain revisions of the edited
files. It creates automatically a CVS repository in a hidden directory and saves revisions
of the files to that repository.

It is possible to visualize the differences between two revisions or between one revision
and current file by using menu command: Files->Revisions->Open revisions list. (it uses
program @code{Tkdiff} to visualize the differences.

It is possible to remove revisions history for a set of selected files (in Files->Revision->
View revised files). The history is removed but the file is not modified. It can save
disk space.

It is possible to activate or deactivate the @code{Auto save} feature in the preferences
window (Edit->Preferences->Auto save). If activated, instead of making backups of the
files it saves automatically revisions of the edited file at fixed intervals.

@node  Auto save,  , Revisions, Using RamDebugger
@section Auto save

@pxref{Revisions}

@node How does it work?, Known bugs, Using RamDebugger, Top
@chapter How does it work?

RamDebugger instruments the source code TCL files in order to make the debugging. Instrumenting
means to add additional lines to the TCL code so as to be able to stop it whereever is
desired. Depending on the context, it instruments all the file or only the @b{proc}'s.

To see the instrumentation of a file, use @code{Utilities->View instrumented file}.

When RamDebugger makes local debugging, it sends the instrumented codes to a slave interp.
Then, it its executed there and can communicate easily.

When Ramdebugger makes remote debugging, it needs some kind of communication between itself
and the debugged program. In UNIX, the command @code{send} is used. In Windows, the package
@code{comm} is used.

Some comments on communication on Windows:
@itemize @bullet
@item @b{DDE}: This communication mode is totally broken. It is unpossible to make it work
except for very simple examples. It just crashes RamDebugger or the full Windows.
@item @b{Windsend}: This package uses COM objects to communicate. It is nice and seems to
work but has a very very slow startup time.
@item @b{comm}: This package emulates the UNIX send by using sockets. It has some problems
in speed when trying connections. Also, it has been necessary to make some trick in order
to identify the interps. This is the package chosen in Windows.
@end itemize

Due to the high dynamics nature of TCL, it is unpossible to make a direct correlation
between source code lines and execution lines. Anyway, it works quite well for normal
TCL code. Try and comment.

@node Known bugs, Additional packages included in the distribution, How does it work?, Top
@chapter Known bugs

That's for sure that there are many not listed bugs. This is only a list of known
bugs that the author could not fix at the time of the release.

@strong{Note:} These bugs should be fixed in last versions.

@itemize @bullet
@item TCL code that returns a value without using @code{return}, will fail when being
debugged
@item When using help, program crashes from time to time. This is probably a bug in
the @b{tkhtml} package
@end itemize

@node Additional packages included in the distribution, License, Known bugs, Top
@chapter Additional packages included in the distribution

RamDebugger needs several packages to work properly. Other packages are just included
to give additional functionality to the user. All the needed packages are included
in the distribution as a convenience to the final user.

Some of the packages have been modified, either to fix some errors or to improve
some capabilities. The packages that have been modified are marked below.
@sp 1
@multitable @columnfractions .3 .3 .2 .2

@item @b{Package}
@tab @b{Author}
@tab @b{License}
@tab @b{Modified}

@item tkcon 
@tab Jeffrey Hobbs 
@tab BSD 
@tab NO
@item comm 
@tab Open Group Res. Ins. 
@tab  BSD 
@tab YES
@item BWidgets 
@tab Unifix 
@tab BSD 
@tab YES
@item dialogwin  
@tab RAMSAN 
@tab BSD 
@tab NO
@item helpviewer 
@tab RAMSAN 
@tab BSD 
@tab NO
@item supergrid  
@tab RAMSAN 
@tab BSD 
@tab NO
@item supertext  
@tab Bryan Oakley 
@tab FREE SOFT 
@tab YES
@item tablelist  
@tab Csaba Nemethi 
@tab FREE SOFT 
@tab  NO
@item visual regexp 
@tab Laurent Riesterer 
@tab GPL 
@tab NO
@item Tkhtml 
@tab D. Richard Hipp 
@tab LGPL 
@tab NO
@item tcllib 
@tab Many 
@tab BSD 
@tab NO
@item icons 
@tab Adrian Davis 
@tab BSD 
@tab NO
@item tkdnd 
@tab George Petasis
@tab BSD 
@tab NO
@item tkdiff 
@tab John M. Klassa
@tab GPL
@tab NO
@end multitable

@node  License,  , Additional packages included in the distribution, Top
@chapter License

@example
This software is copyrighted by Ramon Ribó (RAMSAN) ramsan@@cimne.upc.es.
The following terms apply to all files associated
with the software unless explicitly disclaimed in individual files.

The authors hereby grant permission to use, copy, modify, distribute,
and license this software and its documentation for any purpose, provided
that existing copyright notices are retained in all copies and that this
notice is included verbatim in any distributions. No written agreement,
license, or royalty fee is required for any of the authorized uses.
Modifications to this software may be copyrighted by their authors
and need not follow the licensing terms described here, provided that
the new terms are clearly indicated on the first page of each file where
they apply.

IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.

GOVERNMENT USE: If you are acquiring this software on behalf of the
U.S. government, the Government shall have only "Restricted Rights"
in the software and related documentation as defined in the Federal 
Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
are acquiring the software on behalf of the Department of Defense, the
software shall be classified as "Commercial Computer Software" and the
Government shall have only "Restricted Rights" as defined in Clause
252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
authors grant the U.S. Government and others acting in its behalf
permission to use and distribute the software in accordance with the
terms specified in this license. 
@end example

@iftex
@headings off
@end iftex
@contents
@bye

